'use strict';

const cleanPositionalOperators = require('../schema/cleanPositionalOperators');
const get = require('../get');
<<<<<<< HEAD
const getDiscriminatorByValue = require('../discriminator/getDiscriminatorByValue');
const updatedPathsByArrayFilter = require('../update/updatedPathsByArrayFilter');
=======
>>>>>>> e850dbdd69512603c0d4d12d8d93e241262e32af

/*!
 * Like `schema.path()`, except with a document, because impossible to
 * determine path type without knowing the embedded discriminator key.
 */

<<<<<<< HEAD
module.exports = function getEmbeddedDiscriminatorPath(schema, update, filter, path, options) {
=======
module.exports = function getEmbeddedDiscriminatorPath(schema, update, filter, path) {
>>>>>>> e850dbdd69512603c0d4d12d8d93e241262e32af
  const parts = path.split('.');
  let schematype = null;
  let type = 'adhocOrUndefined';

  filter = filter || {};
  update = update || {};
<<<<<<< HEAD
  const arrayFilters = options != null && Array.isArray(options.arrayFilters) ?
    options.arrayFilters : [];
  const updatedPathsByFilter = updatedPathsByArrayFilter(update);
=======
>>>>>>> e850dbdd69512603c0d4d12d8d93e241262e32af

  for (let i = 0; i < parts.length; ++i) {
    const subpath = cleanPositionalOperators(parts.slice(0, i + 1).join('.'));
    schematype = schema.path(subpath);
    if (schematype == null) {
      continue;
    }
<<<<<<< HEAD

    type = schema.pathType(subpath);
    if ((schematype.$isSingleNested || schematype.$isMongooseDocumentArrayElement) &&
        schematype.schema.discriminators != null) {
      const key = get(schematype, 'schema.options.discriminatorKey');
      const discriminatorValuePath = subpath + '.' + key;
      const discriminatorFilterPath =
        discriminatorValuePath.replace(/\.\d+\./, '.');
      let discriminatorKey = null;

=======
    type = schema.pathType(subpath);
    if ((schematype.$isSingleNested || schematype.$isMongooseDocumentArrayElement) &&
        schematype.schema.discriminators != null) {
      const discriminators = schematype.schema.discriminators;
      const discriminatorValuePath = subpath + '.' +
        get(schematype, 'schema.options.discriminatorKey');
      const discriminatorFilterPath =
        discriminatorValuePath.replace(/\.\d+\./, '.');
      let discriminatorKey = null;
>>>>>>> e850dbdd69512603c0d4d12d8d93e241262e32af
      if (discriminatorValuePath in filter) {
        discriminatorKey = filter[discriminatorValuePath];
      }
      if (discriminatorFilterPath in filter) {
        discriminatorKey = filter[discriminatorFilterPath];
      }
<<<<<<< HEAD

      const wrapperPath = subpath.replace(/\.\d+$/, '');
      if (schematype.$isMongooseDocumentArrayElement &&
          get(filter[wrapperPath], '$elemMatch.' + key) != null) {
        discriminatorKey = filter[wrapperPath].$elemMatch[key];
      }

      if (discriminatorValuePath in update) {
        discriminatorKey = update[discriminatorValuePath];
      }

      for (const filterKey of Object.keys(updatedPathsByFilter)) {
        const schemaKey = updatedPathsByFilter[filterKey] + '.' + key;
        const arrayFilterKey = filterKey + '.' + key;
        if (schemaKey === discriminatorFilterPath) {
          const filter = arrayFilters.find(filter => filter.hasOwnProperty(arrayFilterKey));
          if (filter != null) {
            discriminatorKey = filter[arrayFilterKey];
          }
        }
      }

      if (discriminatorKey == null) {
        continue;
      }

      const discriminatorSchema = getDiscriminatorByValue(schematype.caster.discriminators, discriminatorKey).schema;

      const rest = parts.slice(i + 1).join('.');
      schematype = discriminatorSchema.path(rest);
      if (schematype != null) {
        type = discriminatorSchema._getPathType(rest);
=======
      if (discriminatorKey == null || discriminators[discriminatorKey] == null) {
        continue;
      }
      const rest = parts.slice(i + 1).join('.');
      schematype = discriminators[discriminatorKey].path(rest);
      if (schematype != null) {
        type = discriminators[discriminatorKey]._getPathType(rest);
>>>>>>> e850dbdd69512603c0d4d12d8d93e241262e32af
        break;
      }
    }
  }

  return { type: type, schematype: schematype };
};
